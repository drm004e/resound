
Very much a work in progress and a whiteboard for ideas.

==TCP communication:==
The connection based server protocol:
client sends header block containing command: GET XML or STATUS
server parses the header block:
GET then this is a standard http request and we respond with a complete http response containing a very basic web page about server status
SETXML (Send resound xml) sends a block of resound xml which conforms to the resoundnv.xsd schema. this xml is merged into the current DOM
GETXML (get resound xml) indicates that the client wants some of the current DOM in xml format the client can specify a base object name if it is only interested in one of the main object types

==Parsing and merging the tree==
The server contains a single DOM object that reflects the current system status
LibXML++ does not seem to have a way of having your own object classes inheriting from xmlpp::nodes and getting created from factory methods. The exact creation and deletion model is unclear and we have very strict requirements due to audio threading etc. We are pairing DynamicObjects to nodes in the DOM. We use an abstract class to do this. It is the responsability of each DynamicObject to keep the DOM node up to date with live changes (i.e OSC or runtime related). During the merge stage any DynamicObject may be required to refresh its state from the DOM node. The merging system is responsable for creation and deletion of objects and maintaining consistancy between DOM and DynamicObjects.

The method:
All dynamic objects are child nodes of the main root node <resound>. For each node we find first we check for an id attribute. This attribute reffers to a named dynamic object instance and is a unique identifier for an object inside the engine. We can use the id to check for an object against a map of id against dynamic object. If we find an object under that name then we are updating an existing object. If we cant find one then we are creating a new dynamic object. If we can't find an id then we are creating a new node with an automatically generated unique id code. Once created from an automatic unique id then the client must update its xml reference to obtain the object name. If we find the <delete id="xxx"/> eleement then we are expecting to delete an object from the DOM and its DynamicObject. if we find a <rename id="xxx" newname="yyy"/> tag we are expecting to rename the id entry for the object and update any references.

We use a factory class to create new DynamicObjects from element names. The new DynamicObject is passed its xmlnode at construction. it is responsable for any sub node parsing that may need to be done. Each behaviour has its own base element name so that we can use the same factory system. a dynamic object knows its rtti so can be cast reliably. an objects basic type is also known

<------ need to think about this stuff but I think its getting carried away
Each dynamic object has its own Factory object that can instanciate sub objects from the xml. This effectively gives each object class its own namespace of classes and namespace of object ids. The id lookup system is aware of the tree and will use OSC URI like formatting to find sub names. So we could lookup for an absolute address like "behaviour1/input1" would actually perform a search in the root DynamicObject for "behaviour1" and then behaviour1 would search for "input1". Most of the time during xml creation or update we would be doing relative lookups. This addressing scheme would play a big part in the interlinking of objects... ie set aliases

with this system we have the ability to send small blocks of xml that relate to a small subset of the DOM. i.e. we could send

/// what about if we did it like this?
<new id="genelec1" class="loudspeaker" port="port2"/>
<new id="genelec2" class="loudspeaker" port="port2"/>

// define a new cls
<new id="st1" class="cls">
<new id="L" class="alias" ref="genelec1"/>
<new id="R" class="alias" ref="genelec2"/>
// perhaps even

</new>

<new id="st1.rl" class="alias" ref="geny5"/> // actually makes an alias instance 'rl' inside 'st1'

<new id="" class=""/>
<delete id=""/>
<rename id="" newname=""/>

///// once created we can do things like

//set the gain of alias L in st1
<st1.L gain="1.0"/>

// add a new alias to st1 called C
<st1><new id="C" class="alias" ref="genelec6"/></st1>

Basically each element becomes its own namespace and the fundamental commands new rename and delete manage the creation of the objects. Essentially it just means switching our schema round so that current elements become class attributes. It would mean that our command set becomes extremely powerfull and very readable especially for very small changes.
------>

