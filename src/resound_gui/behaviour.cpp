//   
//   Copyright (c) 2007 David Moore, James Mooney, All Rights Reserved.
//   
//   This program is free software; you can redistribute it and/or
//   modify it under the terms of the GNU General Public License as
//   published by the Free Software Foundation; either version 2 of
//   the License, or (at your option) any later version.
//   
//   This program is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//   GNU General Public License for more details.
//   
//   You should have received a copy of the GNU General Public License
//   along with this program; if not, write to the Free Software
//   Foundation, Inc., 59 Temple Place, Suite 330, Boston,
//   MA 02111-1307 USA
//   
// Class automatically generated by Dev-C++ New Class wizard
#include "sa_cpch.h" // precompiler header

#include "sa_automation.h"
#include "sa_pvar.h"
#include "sa_vumeterwidget.h"
#include "sa_pvarwidgets.h"
#include "sa_behaviour.h" // class's header file

// -------------------------------- Behaviour --------------------------------
// class constructor
SA::Behaviour::Behaviour()
{}
// class destructor
SA::Behaviour::~Behaviour()
{}
int SA::Behaviour::GetNumPVars()
{
	// returns the number of PVars
	return pVarList.size();
}
SA::PVar& SA::Behaviour::GetPVar(int index)
{
	// obtains a PVar by index
	if(index >= 0 && index < pVarList.size()) {
		return pVarList[index];
	} else {
		return nullPVar;
	}
}

// operations used in construction
void SA::Behaviour::AddPVar(wxString name)
{
	// add a new PVar
	PVar p;
	p.SetName(name);
	pVarList.push_back(p);
}
void SA::Behaviour::SetName(wxString _name)
{
	name = _name;
	// rename all PVars !
}
wxString SA::Behaviour::GetName()
{
	return name;
}

// setting and getting the collective for this behaviour
void SA::Behaviour::SetCollective(const Collective& _coll)
{
	collective = _coll;
}
SA::Collective& SA::Behaviour::GetCollective()
{
	return collective;
}

// saving and loading
void SA::Behaviour::Save(wxDataOutputStream& stream)
{
	stream << id; // save the id for this behaviour instance
	stream << name; // save the user name for that instance of the behaviour
	collective.Save(stream); // save the behaviour's collective
}

void SA::Behaviour::Load(wxDataInputStream& stream)
{
	stream >> id; // load the id for this behaviour instance
	stream >> name; // load the user name for that instance of the behaviour
	collective.Load(stream); // load the behaviour's collective.
}

// --------------------------------Behaviour Class--------------------------------

SA::BehaviourClass::BehaviourClass(FourCharId _classId, wxString _className, Behaviour::BehaviourFactory _factory)
{
	classId = _classId;
	className = _className;
	factory = _factory;
}
SA::FourCharId SA::BehaviourClass::GetClassId()
{
	return classId;
}
wxString SA::BehaviourClass::GetName()
{
	return className;
}
SA::Behaviour* SA::BehaviourClass::Create()
{
	// create one of these class of behaviour
	return factory();
}

// -------------------------------- Behaviour manager ----------------------------

SA::BehaviourManager::BehaviourManager()
{
	SetName(_T("Behaviour"));
	nextId = 0;
}
SA::BehaviourManager::~BehaviourManager()
{
	Destroy();
}
void SA::BehaviourManager::RegisterBehaviourClass(BehaviourClass bClass)
{
	// check for existing
	FourCharId classId = bClass.GetClassId();
	BehaviourClassMap::iterator i = classMap.find(classId);
	if(i != classMap.end()) {
		// throw behaviour class already exists
		throw SA::RegisterBehaviourException();
	} else // add the class
	{
		classMap[classId] = bClass; // table look-up
	}
}

SA::Behaviour* SA::BehaviourManager::CreateBehaviourDirect(FourCharId classId)
{
	// first search for the class id
	BehaviourClassMap::iterator i = classMap.find(classId);
	if(i != classMap.end()) {
		// do exception checking here because the plugin may throw
		Behaviour* temp = (*i).second.Create(); // create using the factory

		if(temp) // if its ok
		{
			temp->classId = classId; // set the class id
		}
		return temp;
	} else {
		// classId does not exist
		// throw exception
		throw SA::CreateBehaviourException();
	}
}

SA::Behaviour* SA::BehaviourManager::CreateBehaviour(FourCharId classId)
{
	if(classId == FourCharId()) // check for null type and set
	{
		// have to get user to select type first

		// construct arraystring of all names
		wxArrayString aStr;
		std::vector<FourCharId> idLookup; // temp array for lookup
		for(BehaviourClassMap::iterator i = classMap.begin(); i != classMap.end(); i++)
		{
			idLookup.push_back((*i).first); // store the associated FourCharId by index
			aStr.Add((*i).second.GetName()); // add the string for the dialog
		}
		int classIndex = wxGetSingleChoiceIndex(_T("Please select a behaviour class"),_T("Select BClass"),aStr);

		// lookup the index
		classId = idLookup[classIndex]; // set the class id
	}
	// create a behviour and add it to the manager

	// first search for the class id
	BehaviourClassMap::iterator i = classMap.find(classId);
	if(i != classMap.end()) {
		// do exception checking here because the plugin may throw
		Behaviour* temp = (*i).second.Create(); // create using the factory

		if(temp) // if its ok
		{
			temp->SetName(wxString(_T("new "))+ (*i).second.GetName() + wxString::Format(_T(" Id:%d"),nextId)); // set a temp name
			temp->id = nextId; // set an id for the behaviour
			temp->classId = classId; // set the class id
			behaviourMap[nextId] = temp; // add to the map
			nextId++; // update unique id
		}
		return temp;
	} else {
		// classId does not exist
		// throw exception
		throw SA::CreateBehaviourException();
	}

}

void SA::BehaviourManager::Destroy()
{
	// destroy all behaviours called to clean up
	for(BehaviourMap::iterator i = behaviourMap.begin(); i != behaviourMap.begin(); i++) {
		delete (*i).second;
		(*i).second = 0;
	}
	behaviourMap.clear();
}


// implement the PVarSubSystem interface
SA::PVSSettingsPanel* SA::BehaviourManager::SettingsPanel(wxWindow* parent)
{
	// open a sub system settings dialog

	return 0;
}

SA::PVSSelectPanel* SA::BehaviourManager::SelectPanel(wxWindow* parent)
{
	// open an appropriate dialog for PVar selection return the address or null address
	return new SA::BehaviourSelectPanel(parent,this);
}

SA::PVar& SA::BehaviourManager::GetPVar(const PVarAddress &addr)
{
	// get a pvar at an address - may return a fake pvar
	int id = addr.row;
	BehaviourMap::iterator i = behaviourMap.find(id);
	if(i != behaviourMap.end()) {
		Behaviour* b = (*i).second;
		return b->GetPVar(addr.col); // may return nullPVar // sort this // exception would be better i think
	} else {
		return nullPVar; // sort this out
	}
}

void SA::BehaviourManager::Save(wxDataOutputStream& stream)
{
	stream << behaviourMap.size();// 1. save the number of behaviour instances
	stream << nextId; // 2. save the next available behaviour instance ID
	for (BehaviourMap::iterator i = behaviourMap.begin(); i != behaviourMap.end(); i++) {
		Behaviour* tempBp = (*i).second; // get pointer to existing behaviour instance
		FourCharId tempClassId = tempBp->GetClassId(); // get id for that behaviour's class...
		tempClassId.Save(stream); // 3. ...and save it
		tempBp->Save(stream); // 4. get that behaviour to save itself
	}
}

void SA::BehaviourManager::Load(wxDataInputStream& stream)
{
	Destroy();
	int numOfBehaviourInstances;

	stream >> numOfBehaviourInstances; // 1.
	stream >> nextId; // 2.

	FourCharId tempClassId;
	Behaviour* tempBehaviour;

	for (int n = 0; n < numOfBehaviourInstances; n++) {
		tempClassId.Load(stream); // 3. Get class id for behaviour class
		tempBehaviour = CreateBehaviourDirect(tempClassId);
		tempBehaviour->Load(stream); // get the behaviour to load itself
		behaviourMap[tempBehaviour->GetId()] = tempBehaviour; // add to the map
	}
}


// ------------------------------------ Behaviour Select Panel -----------------------
BEGIN_EVENT_TABLE(SA::BehaviourSelectPanel, PVSSelectPanel)
EVT_BUTTON( BSID_CREATE, SA::BehaviourSelectPanel::OnCreateBehaviour)
END_EVENT_TABLE()

SA::BehaviourSelectPanel::BehaviourSelectPanel(wxWindow* parent, PVarSubSystem* _subSystem)
		: PVSSelectPanel(parent,_subSystem)
{
	// construct the sub objects and sizer
	topSizer = new wxBoxSizer( wxVERTICAL );

	topSizer->Add(new wxStaticText(this,-1,_T("Behaviour panel")));
	topSizer->Add(new wxButton(this,BSID_CREATE,_T("Create Behaviour")));


	// build the dynamic section of the panel
	behaviourSizer = new wxBoxSizer( wxVERTICAL );
	topSizer->Add(behaviourSizer);

	// causes rebuild of the panel
	BuildPanel();

	// layout
	SetSizer(topSizer);
	topSizer->SetSizeHints(this);   // set size hints to honour minimum size
	topSizer->Layout();
}

void SA::BehaviourSelectPanel::BuildPanel()
{
	// cast sub system to known type
	BehaviourManager* behaviourManager = (BehaviourManager*) subSystem;
	behaviourSizer->Remove(0); // remove old sizer
	wxBoxSizer* sizer = new wxBoxSizer( wxVERTICAL );
	behaviourSizer->Add(sizer);

	for(BehaviourMap::iterator i = behaviourManager->GetBehaviourMap().begin(); i !=  behaviourManager->GetBehaviourMap().end(); i++) {
		int id = (*i).first;
		Behaviour* b = (*i).second;
		wxGridSizer* gridSizer = new wxGridSizer(1,0,1,1);
		for(int n = 0; n < b->GetNumPVars(); n++) {
			gridSizer->Add(new SA::AddressSelectWidget(this,-1,PVarAddress(behaviourManager->GetId(),0,id,n)));
		}
		sizer->Add(new wxStaticText(this,-1,b->GetName()));
		sizer->Add(gridSizer);
	}

	topSizer->SetSizeHints(this);   // set size hints to honour minimum size
	topSizer->Layout();

}
void SA::BehaviourSelectPanel::OnCreateBehaviour(wxCommandEvent &event)
{
	// cast sub system to known type
	BehaviourManager* behaviourManager = (BehaviourManager*) subSystem;
	behaviourManager->CreateBehaviour();
	BuildPanel();
}

