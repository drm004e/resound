//   
//   Copyright (c) 2007 David Moore, James Mooney, All Rights Reserved.
//   
//   This program is free software; you can redistribute it and/or
//   modify it under the terms of the GNU General Public License as
//   published by the Free Software Foundation; either version 2 of
//   the License, or (at your option) any later version.
//   
//   This program is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//   GNU General Public License for more details.
//   
//   You should have received a copy of the GNU General Public License
//   along with this program; if not, write to the Free Software
//   Foundation, Inc., 59 Temple Place, Suite 330, Boston,
//   MA 02111-1307 USA
//   
// Class automatically generated by Dev-C++ New Class wizard
#include "pch.h" // precompiler header

#include "automation.h"
#include "pvar.h"
#include "vumeterwidget.h"
#include "pvarwidgets.h"
#include "behaviour.h" // class's header file

#include <sstream>
// -------------------------------- Behaviour --------------------------------
// class constructor
SA::Behaviour::Behaviour()
{}
// class destructor
SA::Behaviour::~Behaviour()
{}


// operations used in construction
void SA::Behaviour::register_parameter(std::string address, ParameterPtr param)
{
	// add a new Parameter
	Parameter p;
	p.set_name(name);
}
void SA::Behaviour::SetName(std::string _name)
{
	name = _name;
	// rename all Parameters !
}
std::string SA::Behaviour::GetName()
{
	return name;
}

// setting and getting the collective for this behaviour
void SA::Behaviour::SetCollective(const Collective& _coll)
{
	collective = _coll;
}
SA::Collective& SA::Behaviour::GetCollective()
{
	return collective;
}



// --------------------------------Behaviour Class--------------------------------

SA::BehaviourClass::BehaviourClass(FourCharId _classId, std::string _className, Behaviour::BehaviourFactory _factory)
{
	classId = _classId;
	className = _className;
	factory = _factory;
}
SA::FourCharId SA::BehaviourClass::GetClassId()
{
	return classId;
}
std::string SA::BehaviourClass::GetName()
{
	return className;
}
SA::Behaviour* SA::BehaviourClass::Create()
{
	// create one of these class of behaviour
	return factory();
}

// -------------------------------- Behaviour manager ----------------------------

SA::BehaviourManager::BehaviourManager() :
ParameterNamespace("Behaviour")
{
	nextId = 0;
}
SA::BehaviourManager::~BehaviourManager()
{
	Destroy();
}
void SA::BehaviourManager::RegisterBehaviourClass(BehaviourClass bClass)
{
	// check for existing
	FourCharId classId = bClass.GetClassId();
	BehaviourClassMap::iterator i = classMap.find(classId);
	if(i != classMap.end()) {
		// throw behaviour class already exists
		throw SA::RegisterBehaviourException();
	} else // add the class
	{
		classMap[classId] = bClass; // table look-up
	}
}

SA::Behaviour* SA::BehaviourManager::CreateBehaviourDirect(FourCharId classId)
{
	// first search for the class id
	BehaviourClassMap::iterator i = classMap.find(classId);
	if(i != classMap.end()) {
		// do exception checking here because the plugin may throw
		Behaviour* temp = (*i).second.Create(); // create using the factory

		if(temp) // if its ok
		{
			temp->classId = classId; // set the class id
		}
		return temp;
	} else {
		// classId does not exist
		// throw exception
		throw SA::CreateBehaviourException();
	}
}

SA::Behaviour* SA::BehaviourManager::CreateBehaviour(FourCharId classId)
{
	if(classId == FourCharId()) // check for null type and set
	{
		// have to get user to select type first

		// construct arraystring of all names
		wxArrayString aStr;
		std::vector<FourCharId> idLookup; // temp array for lookup
		for(BehaviourClassMap::iterator i = classMap.begin(); i != classMap.end(); i++)
		{
			idLookup.push_back((*i).first); // store the associated FourCharId by index
			aStr.Add(wxConvertMB2WX((*i).second.GetName().c_str())); // add the string for the dialog // FIXME wxString conversion problem FIXED
		}
		int classIndex = wxGetSingleChoiceIndex(_T("Please select a behaviour class"),_T("Select Behaviour"),aStr);

		// lookup the index
		classId = idLookup[classIndex]; // set the class id
	}
	// create a behviour and add it to the manager

	// first search for the class id
	BehaviourClassMap::iterator i = classMap.find(classId);
	if(i != classMap.end()) {
		// do exception checking here because the plugin may throw
		Behaviour* temp = (*i).second.Create(); // create using the factory

		if(temp) // if its ok
		{
			std::stringstream s;
			s << "new " << (*i).second.GetName() << " Id:" << nextId;
			temp->SetName(s.str()); // set a temp name//FIXME string conversion FIXED
			temp->id = nextId; // set an id for the behaviour
			temp->classId = classId; // set the class id
			behaviourMap[nextId] = temp; // add to the map
			nextId++; // update unique id
		}
		return temp;
	} else {
		// classId does not exist
		// throw exception
		throw SA::CreateBehaviourException();
	}

}

void SA::BehaviourManager::Destroy()
{
	// destroy all behaviours called to clean up
	for(BehaviourMap::iterator i = behaviourMap.begin(); i != behaviourMap.begin(); i++) {
		delete (*i).second;
		(*i).second = 0;
	}
	behaviourMap.clear();
}


// implement the ParameterNamespace interface
void* SA::BehaviourManager::SettingsPanel(wxWindow* parent)
{
	// open a sub system settings dialog

	return 0;
}

void* SA::BehaviourManager::SelectPanel(wxWindow* parent)
{
	// open an appropriate dialog for Parameter selection return the address or null address
	return new SA::BehaviourSelectPanel(parent,this);
}




// ------------------------------------ Behaviour Select Panel -----------------------
BEGIN_EVENT_TABLE(SA::BehaviourSelectPanel, PVSSelectPanel)
EVT_BUTTON( BSID_CREATE, SA::BehaviourSelectPanel::OnCreateBehaviour)
END_EVENT_TABLE()

SA::BehaviourSelectPanel::BehaviourSelectPanel(wxWindow* parent, ParameterNamespace* _subSystem)
		: PVSSelectPanel(parent,_subSystem)
{
	// construct the sub objects and sizer
	topSizer = new wxBoxSizer( wxVERTICAL );

	topSizer->Add(new wxStaticText(this,-1,_T("Behaviour panel")));
	topSizer->Add(new wxButton(this,BSID_CREATE,_T("Create Behaviour")));


	// build the dynamic section of the panel
	behaviourSizer = new wxBoxSizer( wxVERTICAL );
	topSizer->Add(behaviourSizer);

	// causes rebuild of the panel
	BuildPanel();

	// layout
	SetSizer(topSizer);
	topSizer->SetSizeHints(this);   // set size hints to honour minimum size
	topSizer->Layout();
}

void SA::BehaviourSelectPanel::BuildPanel()
{
	// cast sub system to known type
	BehaviourManager* behaviourManager = (BehaviourManager*) subSystem;
	behaviourSizer->Remove(0); // remove old sizer
	wxBoxSizer* sizer = new wxBoxSizer( wxVERTICAL );
	behaviourSizer->Add(sizer);

	for(BehaviourMap::iterator i = behaviourManager->GetBehaviourMap().begin(); i !=  behaviourManager->GetBehaviourMap().end(); i++) {
		int id = (*i).first;
		Behaviour* b = (*i).second;
		wxGridSizer* gridSizer = new wxGridSizer(1,0,1,1);
		/* // FIXME Parameter mod
		for(int n = 0; n < b->GetNumParameters(); n++) {
			gridSizer->Add(new SA::AddressSelectWidget(this,-1,ParameterAddress("null osc address"))); //FIXME drastic changes to pvar address
		}
		//sizer->Add(new wxStaticText(this,-1,b->GetName())); //FIXME wxString conversion
		*/
		sizer->Add(gridSizer);
	}

	topSizer->SetSizeHints(this);   // set size hints to honour minimum size
	topSizer->Layout();

}
void SA::BehaviourSelectPanel::OnCreateBehaviour(wxCommandEvent &event)
{
	// cast sub system to known type
	BehaviourManager* behaviourManager = (BehaviourManager*) subSystem;
	behaviourManager->CreateBehaviour();
	BuildPanel();
}

