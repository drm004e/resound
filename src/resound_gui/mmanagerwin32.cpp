//   
//   Copyright (c) 2007 David Moore, James Mooney, All Rights Reserved.
//   
//   This program is free software; you can redistribute it and/or
//   modify it under the terms of the GNU General Public License as
//   published by the Free Software Foundation; either version 2 of
//   the License, or (at your option) any later version.
//   
//   This program is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//   GNU General Public License for more details.
//   
//   You should have received a copy of the GNU General Public License
//   along with this program; if not, write to the Free Software
//   Foundation, Inc., 59 Temple Place, Suite 330, Boston,
//   MA 02111-1307 USA
//   
// Class automatically generated by Dev-C++ New Class wizard
#include "pch.h"

#ifdef __WIN32__
    #include "mmanagerwin32.h" // windows platform include
#endif

#include <resound_common/exception.h>

#include "mmanagerwin32.h" // class's header file

// ---------------------------------------- MInputDeviceWin32 ----------------------

MInputDeviceWin32::MInputDeviceWin32(int deviceId)
{
	hMidiIn = 0;
	// get the devs caps
	midiInGetDevCaps(deviceId,&midiInCaps,sizeof(MIDIINCAPS));

	// open the device
	HRESULT err = midiInOpen(&hMidiIn,deviceId,(DWORD)MInputDeviceWin32::MidiInProc,reinterpret_cast<DWORD>(this),CALLBACK_FUNCTION);
	switch(err) {
	case MMSYSERR_NOERROR:
		break;

	case MMSYSERR_ALLOCATED: //The specified resource is already allocated.
	case MMSYSERR_BADDEVICEID: // The specified device identifier is out of range.
	case MMSYSERR_INVALFLAG: // The flags specified by dwFlags are invalid.
	case MMSYSERR_INVALPARAM: // The specified pointer or structure is invalid.
	case MMSYSERR_NOMEM: // The system is unable to allocate or lock memory.
	default:
		throw SA::Exception();
	}
	midiInStart(hMidiIn);

}
MInputDeviceWin32::~MInputDeviceWin32()
{
	if(hMidiIn) {
		midiInStop(hMidiIn);
		midiInClose(hMidiIn);
	}
}

void CALLBACK MInputDeviceWin32::MidiInProc(HMIDIIN _hMidiIn, UINT wMsg, DWORD dwInstance, DWORD dwParam1, DWORD dwParam2)
{
	// handle the message here and pass on to MManager handler

	// cast instance back to MInputDeviceWin32
	MInputDeviceWin32* input = reinterpret_cast<MInputDeviceWin32*>(dwInstance);
	// check the pointer
	if(!input)
		throw SA::Exception(); // throw if invalid pointer

	switch(wMsg) {
	case MIM_OPEN:

		break;
	case MIM_CLOSE:

		break;
	case MIM_DATA:

		input->OnMidiMessage(LOBYTE(LOWORD(dwParam1)),HIBYTE(LOWORD(dwParam1)),LOBYTE(HIWORD(dwParam1)),dwParam2);
		break;
	case MIM_LONGDATA:
	case MIM_ERROR:
	case MIM_LONGERROR:
	case MIM_MOREDATA:
		wxMessageBox(_T("Midi device other callback"));
		throw SA::Exception();
		break;
	}

}

// --------------------------------------- MOutputDeviceWin32 -----------------------

MOutputDeviceWin32::MOutputDeviceWin32(int deviceId)
{
	hMidiOut = 0;
	// get the devs caps
	midiOutGetDevCaps(deviceId,&midiOutCaps,sizeof(MIDIOUTCAPS));

	// open the device
	HRESULT err = midiOutOpen(&hMidiOut,deviceId,0,0,CALLBACK_NULL);
	if(err != MMSYSERR_NOERROR)
		throw SA::Exception();
}
MOutputDeviceWin32::~MOutputDeviceWin32()
{
	if(hMidiOut) {
		midiOutClose(hMidiOut);
	}
}

void MOutputDeviceWin32::SendMidiMessage(MIDI_BYTE status, MIDI_BYTE dataA, MIDI_BYTE dataB)
{
	midiOutShortMsg(hMidiOut, MAKELONG(MAKEWORD(status,dataA),MAKEWORD(dataB,0)));
}

// --------------------------------------- MManager win32 ------------------------------
// class constructor
MManagerWin32::MManagerWin32()
{
	GetDriverNames();
}

// class destructor
MManagerWin32::~MManagerWin32()
{
}

void MManagerWin32::GetDriverNames()
{
	// get the names of all devices
	int numIns = midiInGetNumDevs();
	int numOuts = midiOutGetNumDevs();
	MIDIINCAPS inCaps;
	MIDIOUTCAPS outCaps;
	std::wstring name;
	for(int n = 0; n < numIns; n++) {
		midiInGetDevCaps(n,&inCaps,sizeof(MIDIINCAPS));
		name = inCaps.szPname;
		inputDeviceNames.push_back(name);
	}
	for(int n = 0; n < numOuts; n++) {
		midiOutGetDevCaps(n,&outCaps,sizeof(MIDIOUTCAPS));
		name = outCaps.szPname;
		outputDeviceNames.push_back(name);
	}
}

int MManagerWin32::OpenInputDevice(int id)
{
	try {
		MInputDeviceWin32* device = new MInputDeviceWin32(id);
		inputDevices.push_back(device);
	} catch (SA::Exception& e) {
		wxMessageBox(_T("Error opening input midi device!"));
	}
}

int MManagerWin32::OpenOutputDevice(int id)
{
	try {
		MOutputDeviceWin32* device = new MOutputDeviceWin32(id);
		outputDevices.push_back(device);
	} catch (SA::Exception& e) {
		wxMessageBox(_T("Error opening midi output device!"));
	}
}



