//   
//   Copyright (c) 2007 David Moore, James Mooney, All Rights Reserved.
//   
//   This program is free software; you can redistribute it and/or
//   modify it under the terms of the GNU General Public License as
//   published by the Free Software Foundation; either version 2 of
//   the License, or (at your option) any later version.
//   
//   This program is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//   GNU General Public License for more details.
//   
//   You should have received a copy of the GNU General Public License
//   along with this program; if not, write to the Free Software
//   Foundation, Inc., 59 Temple Place, Suite 330, Boston,
//   MA 02111-1307 USA
//   
// Class automatically generated by Dev-C++ New Class wizard

#ifndef SA_PVAR_H
#define SA_PVAR_H

namespace SA
{
// PVars are targets for automation and control
// PVars use integer arithmetic to eliminate rounding errors
class PVar
{
public:
	PVar();
	virtual ~PVar();

	//values
	virtual int GetValue(); // obtain the value
	virtual void SetValue(int oldVal, int newVal); // set using previous value
	virtual void SetValueDirect(int newVal); // set directly used to initialize
	virtual void OnValueChanged(); //a virtual function called directly by SetValue and SetValue Direct
	virtual void Lock(int _lockedValue); // locks the value - the real value will still be changed but GetValue will return the locked value
	virtual void Unlock(); // get value will return the real value;

	//names
	void SetName(wxString _name); // name this Pvar
	wxString GetName();

private:
	wxString name;
	int value;
	int lockedValue;
	bool isLocked;
};

// PVars are stored in various locations - behaviours, sub systems etc
// a PVar address is used to get hold of a PVar
// the PVarManager deals with this
class PVarAddress
{
public:
	PVarAddress()
	{
		subSystem = type = row = col = -1;
	}
	; // null address
	PVarAddress(int _subSystem, int _type, int _row, int _col)
	{
		subSystem = _subSystem;
		type = _type;
		row = _row;
		col = _col;
	}
	; // null address
	// type row and column are sub addresses - the
	int subSystem; // refers to the subsyetm - ie audiomatrix, behaviour - lighting system etc
	int type; // sub address A depends on sub system
	int row; // sub address B row depends on subsystem
	int col; // sub address C col depends on subsystem

	void Save(wxDataOutputStream& stream);
	void Load(wxDataInputStream& stream);

	//usefull operations
	wxString GetString()
	{
		return wxString::Format(_("%d:%d:%d:%d"),subSystem, type, row, col);
	};

};

// PVarAddressWidgetBase is a base class for gui objects that are linked to a PVarAddresses
// aimed at use in sub system guis
class PVarAddressWidgetBase : public wxWindow
{
public:
	PVarAddressWidgetBase(wxWindow* parent, int id, PVarAddress _addr);
	virtual ~PVarAddressWidgetBase();

	PVarAddress GetAddress();
protected:
	PVarAddress addr;
};



class PVarSubSystem; // pre define

// panel classes for creating sub system interfaces
// base classes act lik wxPanels but with extra defined functions
class PVSSettingsPanel : public wxPanel
{
public:
	PVSSettingsPanel(wxWindow* parent, PVarSubSystem* _subSystem, wxWindowID id = -1, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxSize(300,200), long style = wxTAB_TRAVERSAL, const wxString& name = _("panel"));
protected:
	PVarSubSystem *subSystem;
};
class PVSSelectPanel : public wxPanel
{
public:
	PVSSelectPanel(wxWindow* parent, PVarSubSystem* _subSystem, wxWindowID id = -1, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxSize(300,200), long style = wxTAB_TRAVERSAL, const wxString& name = _("panel"));
protected:
	PVarSubSystem *subSystem;
};

// PVar subsystem - A system for mapping PVar addresses to real PVars
// the subsystem also deals with PVar -> real world variable translation
// typically this is inherited from
// the audio matrix is a PVar sub system
class PVarSubSystem
{
private:
	wxString name;
protected:
	void SetName(wxString _name)
	{
		name = _name;
	};

public:
	wxString GetName()
	{
		return name;
	};
	virtual PVSSettingsPanel* SettingsPanel(wxWindow* parent) = 0; // create a sub system settings dialog
	virtual PVSSelectPanel* SelectPanel(wxWindow* parent) = 0; // create an appropriate dialog for PVar selection return the address or null address
	virtual PVar& GetPVar(const PVarAddress &addr) = 0; // get a pvar at an address - may return a fake pvar

	int GetId()
	{
		return id;
	};
private:
	int id;
	void SetId(int _id)
	{
		id = _id;
	};

	// freind class
	friend class PVarSubSystemManager;
};

// a manager class for PVar subsystems
// subsystems must be manually delete by the creator
// manager will not deal with them
class PVarSubSystemManager
{
private:
	// singleton
	PVarSubSystemManager();
	~PVarSubSystemManager();
	static PVarSubSystemManager* singleton;

public:

	static PVarSubSystemManager& GetSingleton();
	static void Destroy();

	void RegisterPVarSubSystem(PVarSubSystem* subSystem);
	int GetNumSubSystems()
	{
		return subSystemList.size();
	};
	PVarSubSystem& GetSubSystem(int index)
	{
		return *subSystemList[index];
	};

	// pvar related
	PVar& GetPVar(const PVarAddress &addr);
	int PeekPVarValue(const PVarAddress &addr);
private:
	std::vector<PVarSubSystem*> subSystemList;
	PVar nullPVar;
};

// PVars are linked using a PVarlink
// the link is indirect - ie not with a pointer -
// this attempts to avoid possible bugs with invalid pointers due to object creation/deletion
// the link also deals with PVar summing and takes care of previously sent values
class PVarLink
{
public:
	PVarLink();
	PVarLink(const PVarAddress &t);
	PVarLink(const PVarLink& p); // copy construct
	PVarLink& operator=(const PVarLink& p); // assignment
	~PVarLink();

	void SetTarget(const PVarAddress &addr); // set the target
	PVarAddress GetTarget()
	{
		return target;
	};
	void SetValue(int val); // uses the suming system to set a new value
	int GetValue(); // get the current value involves a lookup
	PVar& GetPVar(); // get the target pvar

	void Save(wxDataOutputStream& stream);
	void Load(wxDataInputStream& stream);

private:
	PVarAddress target; // NEEDS LOAD/SAVE FUNCTIONS!
	int lastValue; // the last value sent to the target PVar
};

// elements are the sub groups of collectives
// they contain an array of pvar links, with unique targets within the element
class Element
{
private:
	wxString name;
	typedef std::vector<PVarLink> PVarLinkArray;
	PVarLinkArray pVarLinkArray;

public:
	Element();
	~Element();

	// set the value of all pvar targets in this element
	void SetValue(int value);

	// collective name
	wxString GetName()
	{
		return name;
	};
	void SetName(wxString _name)
	{
		name = _name;
	};

	// save and load
	void Save(wxDataOutputStream& stream);
	void Load(wxDataInputStream& stream);

	// PVarLink insert and add
	void AddLink(const PVarLink& link = PVarLink());
	void InsertLink(int index, const PVarLink& link = PVarLink());
	void PrependLink(int index, const PVarLink& link = PVarLink());

	int GetNumLinks()
	{
		return pVarLinkArray.size();
	};
	// overloaded indexing
	PVarLink& operator[](int index)
	{
		return pVarLinkArray[index];
	};
};

// collectives form the basis of grouped assignment
// collectives are simply a structured set of links
// behaviours operate
class Collective
{
private:
	wxString name;
	// the array of elements
	typedef std::vector<Element> ElementArray;
	ElementArray elementArray;

public:
	Collective();
	~Collective();

	// set the value for every link in every element
	void SetValue(int value);

	// collective name
	wxString GetName()
	{
		return name;
	};
	void SetName(wxString _name)
	{
		name = _name;
	};

	// save and load
	void Save(wxDataOutputStream& stream);
	void Load(wxDataInputStream& stream);

	// gui helpers
	void Display();

	// element insertion
	void AddElement(const Element& element = Element()); // add element at end
	void InsertElement(int index, const Element& element = Element()); // insert at index
	void PrependElement(int index, const Element& element = Element()); // insert before element at index
	void RemoveElement(int index); // remove element at index
	int GetNumElements()
	{
		return elementArray.size();
	};
	// overloaded indexing
	Element& operator[](int index)
	{
		return elementArray[index];
	};
};

// collectivecursoredit is a utility class for manipulating a collective
// using a current position cursor
class CollectiveCursorEdit
{
private:
	Collective* collective; // the collective being edited
	int cursorIndex;
public:
	CollectiveCursorEdit(Collective* _collective);// construct passing collective to be edited

	Collective* GetCollective();  // return pointer to the collective being edited
	Element& GetCurrentElement(); // return reference to the element indicated by current cursor position
	int GetCursorPosition(); // get the cursor position -1 is head element, 0 is first real element
	void SetCursorPosition(int newCursorIndex); // set the cursor position

	void AddLink(const PVarLink& link = PVarLink()); // adds a link at the current location
	void ClearLinks(); // clear all of the PVarLinks at the current cursor location but keep the element itself
	void Next(); // moves to the next element
	void Previous(); // moves to the previous element
	void Insert(const Element& element = Element()); // insert element after current element // cursor is set to the new element
	void ShiftLeft(); // not implemented yet
	void ShiftRight(); // not implemented yet
	void Remove(); // removes the current element
	/* TODO (James#1#): At present Remove() decrements cursor ; it would be better if it
	                    didn't but this would mean checking if its pointing to 
	                    an element beyond the end of the collective (i.e. 
	                    if user deleted the last element) */

	void SetHead(); // move to the head element // move to element -1
	void SetFirst(); // move to the last element
	void SetLast(); // move to the last element
};

}

#endif // SA_PVAR_H
