//   
//   Copyright (c) 2007 David Moore, James Mooney, All Rights Reserved.
//   
//   This program is free software; you can redistribute it and/or
//   modify it under the terms of the GNU General Public License as
//   published by the Free Software Foundation; either version 2 of
//   the License, or (at your option) any later version.
//   
//   This program is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//   GNU General Public License for more details.
//   
//   You should have received a copy of the GNU General Public License
//   along with this program; if not, write to the Free Software
//   Foundation, Inc., 59 Temple Place, Suite 330, Boston,
//   MA 02111-1307 USA
//   
// Class automatically generated by Dev-C++ New Class wizard

#include "pvar.h" // class's header file
#include <iostream>
// -------------------------------- Parameter --------------------------------
SA::Parameter::Parameter() :
m_value(0),
m_name("No name"),
m_isLocked(false)
{}

SA::Parameter::~Parameter()
{}

int SA::Parameter::get_value()
{
	// obtain the value
	if(m_isLocked)
		return m_lockedValue;
	return m_value;
}
void SA::Parameter::set_value(int oldVal, int newVal)
{
	// set using previous value
	int delta = newVal - oldVal;
	if(delta != 0) {
		m_value += delta; // summing
		this->on_value_changed(); // call virtual notification function
	}

}
void SA::Parameter::set_value_direct(int newVal)
{
	// set directly used to initialize
	if(newVal != m_value) {
		m_value = newVal; // direct
		this->on_value_changed(); // call virtual notification function
	}
}
void SA::Parameter::lock(int lockedValue)
{
	// locks the value - the real value will still be changed but GetValue will return the locked value
	m_isLocked = true;
	m_lockedValue = lockedValue;
	this->on_value_changed(); // call virtual notification function
}

void SA::Parameter::unlock()
{
	// get value will return the real value;
	m_isLocked = false;
	this->on_value_changed(); // call virtual notification function
}

void SA::Parameter::on_value_changed()
{}

void SA::Parameter::set_name(std::string name)
{
	m_name = name;
}

std::string SA::Parameter::get_name()
{
	return m_name;
}
// -------------------------------- ParameterNamespace ------------------
void SA::ParameterNamespace::register_parameter(std::string address, ParameterPtr param){
	SA::ParameterNamespaceManager::GetSingleton().register_parameter(std::string("/") + m_name + address, param);
}
// -------------------------------- ParameterNamespaceManager ------------------
// singleton manager object
SA::ParameterNamespaceManager* SA::ParameterNamespaceManager::singleton = 0;
SA::ParameterNamespaceManager& SA::ParameterNamespaceManager::GetSingleton()
{
	if(singleton == 0) {
		singleton = new ParameterNamespaceManager();
	}
	return *singleton;
}
void SA::ParameterNamespaceManager::Destroy()
{
	if(singleton)
		delete singleton;
}

SA::ParameterNamespaceManager::ParameterNamespaceManager()
{}
SA::ParameterNamespaceManager::~ParameterNamespaceManager()
{
}
void SA::ParameterNamespaceManager::RegisterParameterNamespace(ParameterNamespace* subSystem)
{
	//subSystem->SetId(subSystemList.size()); // sets the global id of this sub system // FIXME sub system ids no longer exist
	subSystemList.push_back(subSystem);
}
SA::ParameterPtr SA::ParameterNamespaceManager::GetParameter(const ParameterAddress &addr)
{
	
	ParameterAddressMap::iterator it = m_parameterAddressMap.find(addr);
	if(it != m_parameterAddressMap.end()){
		return it->second;
	} else {
		throw ParameterAddressException(addr);
	}
}
int SA::ParameterNamespaceManager::PeekParameterValue(const ParameterAddress &addr)
{
	return GetParameter(addr)->get_value();
}
void SA::ParameterNamespaceManager::register_parameter(std::string address, ParameterPtr param){
	ParameterAddressMap::iterator it = m_parameterAddressMap.find(address);
	if(it != m_parameterAddressMap.end()){
		throw ParameterAddressException(address); // non unique address registered
	} else {
		m_parameterAddressMap[address]=param;
		std::cout << "Registered Parameter: " << address << std::endl;
	}
}
// -------------------------------- Parameter link --------------------------------
SA::ParameterLink::ParameterLink() :
m_lastValue(0)
{}

SA::ParameterLink::ParameterLink(const ParameterAddress &t) :
m_lastValue(0),
m_targetAddress(t)
{}

// copy construct
// each ParameterLink must operat successfully on targets so
// copy and assignment must take this into account
// targets are maintained but influence on values is reset
SA::ParameterLink::ParameterLink(const ParameterLink& p) :
m_lastValue(0),
m_targetAddress(p.m_targetAddress)
{}

//assignemtn
SA::ParameterLink& SA::ParameterLink::operator=(const ParameterLink& p){
	if(&p == this) {
		return *this; // ignore self assignment
	}
	SetValue(0); // remove influence on old target
	m_targetAddress = p.m_targetAddress; // get the new target
	m_lastValue = 0; // set last value to 0
	return *this;
}


SA::ParameterLink::~ParameterLink(){
	SetValue(0); // get rid of influence before destroying
}

void SA::ParameterLink::SetTarget(const ParameterAddress &addr){
	// set the target - assumes valid address
	// notify previous target and remove influence
	SetValue(0); // removes any influence
	m_targetAddress = addr;
}
void SA::ParameterLink::SetValue(int val){
	// uses the suming system to set a new value
	if(val != m_lastValue) {
		// only update if different because it avoids calls to obtain the target param
		ParameterNamespaceManager::GetSingleton().GetParameter(m_targetAddress)->set_value(m_lastValue, val);
		m_lastValue = val;
	}
}
int SA::ParameterLink::GetValue()
{
	return ParameterNamespaceManager::GetSingleton().PeekParameterValue(m_targetAddress);
}

SA::ParameterPtr SA::ParameterLink::GetParameter()
{
	return ParameterNamespaceManager::GetSingleton().GetParameter(m_targetAddress);
}


// -------------------------------- Element ------------------------------------------

SA::Element::Element()
{}
SA::Element::~Element()
{}
void SA::Element::SetValue(int value)
{
	for(int n = 0; n < pVarLinkArray.size(); n++) {
		pVarLinkArray[n].SetValue(value);
	}
}
// ParameterLink insert and add
void SA::Element::AddLink(const ParameterLink& link)
{
	pVarLinkArray.push_back(link);
}
void SA::Element::InsertLink(int index, const ParameterLink& link)
{
	// insert at index
	ParameterLinkArray::iterator it = pVarLinkArray.begin() + index + 1;
	pVarLinkArray.insert(it,link);
}
void SA::Element::PrependLink(int index, const ParameterLink& link)
{
	// insert before index
	ParameterLinkArray::iterator it = pVarLinkArray.begin() + index;
	pVarLinkArray.insert(it,link);
}



// -------------------------------- Collective ---------------------------------------
SA::Collective::Collective()
{
	// AddElement(); // a single basic element
}
SA::Collective::~Collective()
{
}

void SA::Collective::SetValue(int value)
{
	for(int n = 0; n < elementArray.size(); n++) {
		elementArray[n].SetValue(value);
	}
}

void SA::Collective::Display()
{
/* FIXME removal of gui functions from pvar
	std::string str;
	for(int el = 0; el < elementArray.size(); el++) {
		str.Append(std::string::Format(_T("Element %d\n"),el));

		Element& element = elementArray[el];
		for(int n = 0; n < element.GetNumLinks(); n++) {
			ParameterLink& link = element[n];
			ParameterAddress pVarAddress = link.GetTarget();
			ParameterPtr pVar = link.GetParameter();
			str.Append(_T(" |- ( "));
			//str.Append(pVarAddress.get_address().c_str()); // FIXME string conversion
			str.Append(_T(" ) - "));
			//str.Append(pVar.get_name()); // FIXME string conversion
			str.Append(_T("\n"));
		}
	}
	wxMessageBox(str,_T("Collective"));
*/
}

void SA::Collective::AddElement(const Element& element)
{
	// add element at end
	elementArray.push_back(element);
};
void SA::Collective::InsertElement(int index, const Element& element)
{
	// insert at index
	ElementArray::iterator it = elementArray.begin() + index + 1;
	elementArray.insert(it,element);

};
void SA::Collective::PrependElement(int index, const Element& element)
{
	// insert before element at index
	ElementArray::iterator it = elementArray.begin() + index;
	elementArray.insert(it,element);
};

void SA::Collective::RemoveElement(int index)
{
	ElementArray::iterator it = elementArray.begin() + index;
	elementArray.erase(it);
}



// --------------------------------- Collective Cursor Edit ----------------------------
SA::CollectiveCursorEdit::CollectiveCursorEdit(Collective* _collective)
{
	// construct passing collective to be edited
	collective = _collective;
	SetLast(); // move to last element;
}

SA::Collective* SA::CollectiveCursorEdit::GetCollective()
{
	return collective;
}

SA::Element& SA::CollectiveCursorEdit::GetCurrentElement() // change to & in implementation!
{
	if (cursorIndex == -1) // if we are asking (erroneously) for the element at index -1...
	{
		/* TODO (James#5#): Un-caught exception!
		                    We should never ask for the element at index -1, 
		                    because this doesn't exist (it is the head). */
		throw std::exception(); // we don't need this actually, as long as we only ask for a +ve index!
	} else // if the cursor position is a valid element...
	{
		return (*collective)[cursorIndex]; // ...return a reference to it
	}
}

int SA::CollectiveCursorEdit::GetCursorPosition()
{
	// get the cursor position -1 is head element, 0 is first real element
	return cursorIndex;
}

void SA::CollectiveCursorEdit::SetCursorPosition(int newCursorIndex)
{
	if (newCursorIndex < -1) // if we tried to set the cursor to before the head 'element'...
	{
		cursorIndex = -1; // ...set cursor to head
	} else if (newCursorIndex > collective->GetNumElements()-1) // if we tried to set it to a non-existent element
	{
		cursorIndex = collective->GetNumElements()-1; // set it to the last existing element in the collective
	} else {
		cursorIndex = newCursorIndex; // is this 100% safe? Do we want to check that this element exists?
	}
}

void SA::CollectiveCursorEdit::AddLink(const ParameterLink& link)
{
	// adds a link at the current location

	// check for head
	if(cursorIndex == -1) {
		Insert();
	}
	(*collective)[cursorIndex].AddLink(link);
}

void SA::CollectiveCursorEdit::ClearLinks()
{
	// FIXME gui functionality removed from pvar
	//wxMessageBox(_T("CollectiveCursorEdit::ClearLinks() - Not implemented yet!"));
}

void SA::CollectiveCursorEdit::Next()
{
	// moves to the next element
	int numElements = collective->GetNumElements();
	++cursorIndex;
	if(cursorIndex >= numElements) {
		cursorIndex = numElements-1;
	}
}
void SA::CollectiveCursorEdit::Previous()
{
	// moves to the previous element
	--cursorIndex;
	if(cursorIndex < -1) {
		cursorIndex = -1;
	}
}
void SA::CollectiveCursorEdit::Insert(const Element& element)
{
	// insert element after current element // cursor is set to the new element
	collective->PrependElement(cursorIndex + 1, element);
	cursorIndex++;
}

void SA::CollectiveCursorEdit::ShiftLeft()
{
	if (cursorIndex >= 1) // shift left cannot apply to the first element or head!
	{
		Element elementToBeShifted = GetCurrentElement(); // make a copy of the current element
		Remove(); // remove it
		Previous(); // shift the cursor back...
		Insert(elementToBeShifted);
	}
}

void SA::CollectiveCursorEdit::ShiftRight()
{
	if (cursorIndex > -1 && cursorIndex < collective->GetNumElements()-1) // shift right cannot apply to last element or head!
	{
		Element elementToBeShifted = GetCurrentElement(); // make a copy of the current element
		Remove(); // remove it
		Next(); // shift cursor forwards
		Insert(elementToBeShifted);
	}
}

/// Removes the current element as indicated by the cursor position
/// Cursor is then set to the previous element or head
void SA::CollectiveCursorEdit::Remove()
{
	if (cursorIndex > -1) // as long as we are not at the collective head...
	{
		collective->RemoveElement(cursorIndex); // ...remove element from collective...
		Previous(); // ...and call own function to decrement the cursor
	}
	// Do we need a check to see if the cursor is BEYOND the last valid element???
}

void SA::CollectiveCursorEdit::SetHead()
{
	// move to the head element // move to element -1
	cursorIndex = -1;
}
void SA::CollectiveCursorEdit::SetFirst()
{
	// move to the first element
	cursorIndex = 0;
}
void SA::CollectiveCursorEdit::SetLast()
{
	// move to the last element
	cursorIndex = collective->GetNumElements() - 1;
}
