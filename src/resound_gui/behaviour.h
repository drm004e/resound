//   
//   Copyright (c) 2007 David Moore, James Mooney, All Rights Reserved.
//   
//   This program is free software; you can redistribute it and/or
//   modify it under the terms of the GNU General Public License as
//   published by the Free Software Foundation; either version 2 of
//   the License, or (at your option) any later version.
//   
//   This program is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//   GNU General Public License for more details.
//   
//   You should have received a copy of the GNU General Public License
//   along with this program; if not, write to the Free Software
//   Foundation, Inc., 59 Temple Place, Suite 330, Boston,
//   MA 02111-1307 USA
//   
// Class automatically generated by Dev-C++ New Class wizard

#ifndef __BEHAVIOUR_H
#define __BEHAVIOUR_H

#include "pvarwidgets.h"

namespace Resound
{
// pre defined
class Behaviour;

/// behaviour smart pointers
typedef boost::shared_ptr<Behaviour> BehaviourPtr;

/// a behaviour factory method pointer
typedef BehaviourPtr (*BehaviourFactory)();

/// a class identifier used by the behaviour factory
typedef std::string BehaviourClassId;

class BehaviourParameter : public Parameter{
public:
	BehaviourParameter(){};
	BehaviourParameter(const EntityName& name, Behaviour* parentBehaviour) : 
		Parameter(name),
		m_parentBehaviour(parentBehaviour)
		{}
	virtual void on_value_changed();
	virtual void dummy(){};
private:
	Behaviour* m_parentBehaviour;

	friend class boost::serialization::access; ///< allow serialization access at low level
	/// serialization definition
	template<class Archive>
   	 void serialize(Archive & ar, const unsigned int version)
   	 {
		ar & BOOST_SERIALIZATION_BASE_OBJECT_NVP(Parameter);
		ar & BOOST_SERIALIZATION_NVP(m_parentBehaviour);
    	 }
};

/// behaviours form the system for grouping and automation
/// automation is via the sa_automation core
/// behaviour is a base class for a pluginable SDK
class Behaviour
{
public:
	Behaviour(){};
	Behaviour(std::string name); ///< construction must have a name
	virtual ~Behaviour(); ///< destruct

	/// set the behaviours public name
	/// warning this causes re-addressing of parameters
	void set_name(std::string name);

	/// return the behaviours name
	std::string get_name();

	/// return the behaviour unique id
	int get_id(){ return m_id;}

	/// return the class id
	BehaviourClassId get_class_id(){return m_classId;}

	/// set the collective used by this behaviour
	void set_collective(const Collective& coll);

	/// return the collective used by this behaviour
	Collective& get_collective();

	/// return a pointer to a specific indexed parameter 
	ParameterPtr get_parameter(int index){ return m_parameters.at(index); }
	/// return the number of parameters in this behaviour
	int get_num_parameters(){ return m_parameters.size(); }

	/// one of the behaviours parameters has altered
	/// overload with behaviour algorithm
	virtual void on_parameter_changed(){};

protected:
	/// register a parameter addressable by the global system
	void register_parameter(ParameterPtr param); // add a new Parameter, auto register it with the global namespace
private:
	std::string m_name; ///< behaviours user defined name (&)
	Collective m_collective; ///< this behaviours current collective (&)
	int m_id; ///< the unique id for this behaviour (&)
	BehaviourClassId m_classId; ///< the class id string (&)
	ParameterArray m_parameters;
	friend class BehaviourManager;
	/// return the next global behaviour id
	static int get_global_id(){return s_globalId++;}
	static int s_globalId;  // FIXME may need to reset s_global id static at load time???

	friend class boost::serialization::access; ///< allow serialization access at low level
	/// serialization definition
	template<class Archive>
   	 void serialize(Archive & ar, const unsigned int version)
  	 {
      	  	ar & BOOST_SERIALIZATION_NVP(m_name);
		ar & BOOST_SERIALIZATION_NVP(m_collective);
		ar & BOOST_SERIALIZATION_NVP(m_id);
		ar & BOOST_SERIALIZATION_NVP(m_classId);
		ar & BOOST_SERIALIZATION_NVP(m_parameters);
		// FIXME may need to reset s_global id static at load time???
   	 }
};

// TODO consider possible template implementation for behaviour factory?
class BehaviourClassFactory
{
public:
	/// default construct
	BehaviourClassFactory() : m_factory(0) {}
	/// construct with id,name and factory ptr
	BehaviourClassFactory(BehaviourClassId classId, std::string classNiceName, BehaviourFactory factory);
	/// return the class id
	BehaviourClassId get_class_id();
	std::string get_name();
	BehaviourPtr create(); // create one of these class of behaviour

private:
	BehaviourClassId m_classId; // a unique identifier for a behaviour class // see similar to vst plugin 4 char id
	std::string m_classNiceName;
	BehaviourFactory m_factory;

	friend class boost::serialization::access; ///< allow serialization access at low level
	/// serialization definition
	template<class Archive>
    void serialize(Archive & ar, const unsigned int version)
    {
        ar & BOOST_SERIALIZATION_NVP(m_classId);
	ar & BOOST_SERIALIZATION_NVP(m_classNiceName);
	//ar & BOOST_SERIALIZATION_NVP(m_factory); //FIXME consider is it even nessersary to serialize the behaviour factories
    }
};

// behaviour map
/// a map of behaviours against unique ids
typedef std::map<int,BehaviourPtr> BehaviourMap;

/// a map of behaviour factorys against class ids
typedef std::map<BehaviourClassId, BehaviourClassFactory> BehaviourClassFactoryMap;

/// An exception caused by attempt to create behaviour from unknown four character id.
class CreateBehaviourException : public Resound::Exception
{
public:
	const char* what() const throw()
	{
		return "An unknown behaviour class id was requested\nwhen trying to create a behaviour";
	};
};

/// An exception caused by repitition of behaviour idetifiers.
class RegisterBehaviourException : public Resound::Exception
{
public:
	const char* what() const throw()
	{
		return "A behaviour class attempted to register\nan identifier which was already in use";
	};
};

/// BehaviourManager : A pvar subsystem for managing behaviours.
/// it manages all behaviours created and deals with routing of parameters
class BehaviourManager : public ParameterNamespace
{
public:
	BehaviourManager();
	virtual ~BehaviourManager();

	/// register a behaviour class factory
	void register_behaviour_class_factory(BehaviourClassFactory bClass);
	/// create a behaviour but dont register it or set its unique id
	BehaviourPtr create_behaviour_direct(BehaviourClassId classId); // TODO do we need this
	/// create a behaviour and manage it
	/// if a class id is not specified this will pop up a selection dialog // TODO consider other options remove GUI from behaviour manager
	BehaviourPtr create_behaviour(BehaviourClassId classId = "");

	/// return the behaviour map
	BehaviourMap& get_behaviour_map(){return m_behaviourMap;} //TODO consider a more secure way of doing this

	virtual void dummy(){};
private:

	int m_nextId; ///< id specified to the map as its created
	BehaviourClassFactoryMap m_classMap; ///< a list of all registered creatable types
	BehaviourMap m_behaviourMap; ///< maps behaiours to int id's // id's used to look up

	friend class boost::serialization::access; ///< allow serialization access at low level
	/// serialization definition
	template<class Archive>
    void serialize(Archive & ar, const unsigned int version)
    {
	ar & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ParameterNamespace);
        ar & BOOST_SERIALIZATION_NVP(m_nextId);
	ar & BOOST_SERIALIZATION_NVP(m_classMap);
	ar & BOOST_SERIALIZATION_NVP(m_behaviourMap);
    }
};

// Behaviour selection panel //TODO move this out of behaviour
enum BSID
{
    BSID_CREATE = 1,
    BSID_EDITOR,
    BSID_RENAME
};
class BehaviourSelectPanel : public PVSSelectPanel
{
public:
	BehaviourSelectPanel(wxWindow* parent, ParameterNamespace* _subSystem);
	void BuildPanel();
private:
	wxBoxSizer *topSizer;
	wxBoxSizer *behaviourSizer;
	// events
	void OnCreateBehaviour(wxCommandEvent &event);
	DECLARE_EVENT_TABLE()
};

}
#endif // __BEHAVIOUR_H
