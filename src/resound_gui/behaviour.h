//   
//   Copyright (c) 2007 David Moore, James Mooney, All Rights Reserved.
//   
//   This program is free software; you can redistribute it and/or
//   modify it under the terms of the GNU General Public License as
//   published by the Free Software Foundation; either version 2 of
//   the License, or (at your option) any later version.
//   
//   This program is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//   GNU General Public License for more details.
//   
//   You should have received a copy of the GNU General Public License
//   along with this program; if not, write to the Free Software
//   Foundation, Inc., 59 Temple Place, Suite 330, Boston,
//   MA 02111-1307 USA
//   
// Class automatically generated by Dev-C++ New Class wizard

#ifndef SA_BEHAVIOUR_H
#define SA_BEHAVIOUR_H

#include "pvarwidgets.h"

namespace SA
{
// data type for class id codes
struct FourCharId
{
	// may need to add features to ensure endianness !
	union{
		struct {
			char a, b, c, d;
		};
		unsigned int id;
	};
	// constructors
	FourCharId()
	{
		id = 0;
	};
	FourCharId(const char* code)
	{
		a = code[0];
		b = code[1];
		c = code[2];
		d = code[3];
	};
	FourCharId(char _a, char _b, char _c, char _d)
	{
		a = _a;
		b = _b;
		c = _c;
		d = _d;
	};
	FourCharId(unsigned int _id)
	{
		id = _id;
	};
	bool operator ==(const FourCharId& op) const
	{
		return id == op.id;
	};
	bool operator !=(const FourCharId& op) const
	{
		return id != op.id;
	};
	bool operator <(const FourCharId& op) const
	{
		return id < op.id;
	};

};

class BehaviourEditor; // predefinition

// behaviours form the system for grouping and automation
// automation is via the sa_automation core
// behaviour is a base class for a pluginable SDK
class Behaviour
{
public:
	// factory typedef
	typedef Behaviour* (*BehaviourFactory)();

	// construction
	Behaviour();
	virtual ~Behaviour();

	// set get name
	void SetName(std::string _name);
	std::string GetName();

	// get associated ids
	int GetId()
	{
		return id;
	};
	FourCharId GetClassId()
	{
		return classId;
	};

	// setting and getting the collective for this behaviour
	void SetCollective(const Collective& _coll);
	Collective& GetCollective();

protected:
	// operations used in construction
	void register_parameter(std::string address, ParameterPtr param); // add a new Parameter, auto register it with the global namespace

private:
	std::string name;

	Collective collective; // this behaviours collective // added 19 july // SAVE THIS

	int id;
	FourCharId classId;

	// the behaviours editor ptr
	BehaviourEditor* editor;

	friend class BehaviourManager; // this can set the id FIXME friend is probably yoink consider removal
};

// base class for behaviour editors
class BehaviourEditor : public wxPanel
	{}
;



class BehaviourClass
{
public:
	// construct with a factory pointer // see typedef inside Behaviour
	BehaviourClass()
	{
		factory = 0;
	}
	; // default constructor for std::container
	BehaviourClass(FourCharId _classId, std::string _className, Behaviour::BehaviourFactory _factory);
	FourCharId GetClassId();
	std::string GetName();
	Behaviour* Create(); // create one of these class of behaviour

private:
	FourCharId classId; // a unique identifier for a behaviour class // see similar to vst plugin 4 char id
	std::string className;
	Behaviour::BehaviourFactory factory;
};

// behaviour map
typedef std::map<int,Behaviour*> BehaviourMap;
typedef std::map<FourCharId, BehaviourClass> BehaviourClassMap;

/// An exception caused by attempt to create behaviour from unknown four character id.
class CreateBehaviourException : public SA::Exception
{
public:
	const char* what() const throw()
	{
		return "An unknown behaviour class id was requested\nwhen trying to create a behaviour";
	};
};

/// An exception caused by repitition of behaviour idetifiers.
class RegisterBehaviourException : public SA::Exception
{
public:
	const char* what() const throw()
	{
		return "A behaviour class attempted to register\nan identifier which was already in use";
	};
};

/// BehaviourManager : A pvar subsystem for managing behaviours.
/// it manages all behaviours created and deals with routing of parameters
class BehaviourManager : public ParameterNamespace
{
public:
	BehaviourManager();
	virtual ~BehaviourManager();

	void RegisterBehaviourClass(BehaviourClass bClass);
	Behaviour* CreateBehaviourDirect(FourCharId classId); // create a behviour and return it (do not add to manager or set ID)
	Behaviour* CreateBehaviour(FourCharId classId = FourCharId()); // create a behviour and add it to the manager // pops a selector dialog if classId not set
	void Destroy(); // destroy all behaviours called to clean up


	// implement the ParameterNamespace interface
	virtual void* SettingsPanel(wxWindow* parent); // create a sub system settings dialog
	virtual void* SelectPanel(wxWindow* parent); // create an appropriate dialog for Parameter selection return the address or null address

	BehaviourMap& GetBehaviourMap()
	{
		return behaviourMap;
	};
private:
	Parameter nullParameter;
	int nextId; // id specified to the map as its created
	BehaviourClassMap classMap; // a list of all registered creatable types
	BehaviourMap behaviourMap; // maps behaiours to int id's // id's used to look up


};

// Behaviour selection panel
enum BSID
{
    BSID_CREATE = 1,
    BSID_EDITOR,
    BSID_RENAME
};
class BehaviourSelectPanel : public PVSSelectPanel
{
public:
	BehaviourSelectPanel(wxWindow* parent, ParameterNamespace* _subSystem);
	void BuildPanel();
private:
	wxBoxSizer *topSizer;
	wxBoxSizer *behaviourSizer;
	// events
	void OnCreateBehaviour(wxCommandEvent &event);
	DECLARE_EVENT_TABLE()
};

}
#endif // SA_BEHAVIOUR_H
