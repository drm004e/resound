//   
//   Copyright (c) 2007 David Moore, James Mooney, All Rights Reserved.
//   
//   This program is free software; you can redistribute it and/or
//   modify it under the terms of the GNU General Public License as
//   published by the Free Software Foundation; either version 2 of
//   the License, or (at your option) any later version.
//   
//   This program is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//   GNU General Public License for more details.
//   
//   You should have received a copy of the GNU General Public License
//   along with this program; if not, write to the Free Software
//   Foundation, Inc., 59 Temple Place, Suite 330, Boston,
//   MA 02111-1307 USA
//   
// Class automatically generated by Dev-C++ New Class wizard
#include "pch.h" // precompiler header

#include "automation.h"
#include "pvar.h"
#include "behaviour.h" // inheriting class's header file
#include "basebehaviour.h" // class's header file

// ----------------------------------------- Registration function -----------
void SA::RegisterBaseBehaviours(BehaviourManager* theManager)
{
	theManager->RegisterBehaviourClass(BehaviourClass(FourCharId('bpgr'),"Proportional Group", BPGroup::Factory));
	theManager->RegisterBehaviourClass(BehaviourClass(FourCharId('mpcr'),"Multipoint Crossfade", BMultiCrossfade::Factory));
	theManager->RegisterBehaviourClass(BehaviourClass(FourCharId('wave'),"Sinusoidal Wave", BWave::Factory));
	theManager->RegisterBehaviourClass(BehaviourClass(FourCharId('mwve'),"Mexican Wave", BMexicanWave::Factory));
	theManager->RegisterBehaviourClass(BehaviourClass(FourCharId('rand'),"Random", BRandom::Factory));
}

// ----------------------------------------- Proportinal group ---------------

// class constructor
SA::BPGroup::BPGroup()
{
	register_parameter("level", ParameterPtr(new Parameter));
	register_parameter("min", ParameterPtr(new Parameter));
	register_parameter("max", ParameterPtr(new Parameter));
}

// class destructor
SA::BPGroup::~BPGroup()
{
	// insert your code here
}

// ---------------------------------------- Multicrossfade ------------------

// class constructor
SA::BMultiCrossfade::BMultiCrossfade()
{
	register_parameter("position", ParameterPtr(new Parameter));
}

// class destructor
SA::BMultiCrossfade::~BMultiCrossfade()
{
	// insert your code here
}

// ---------------------------------------- Wave ----------------------------
// class constructor
SA::BWave::BWave() :
m_amp(new Parameter),
m_freq(new Parameter)
{
	register_parameter("amp", m_amp);
	register_parameter("freq", m_freq);

	// init
	angle = 0;
	/* TODO (dave#1#): angles have the potential to go behond float range over time
	may need better solution - this applies to all behaviours
	possible sollutions are to table lookup the sin wave and use bitwise & to cycle
	or a simple if statement garanteing range
	personnaly I would prefer the table lookup*/
}
// class destructor
SA::BWave::~BWave()
{}

// overloaded
void SA::BWave::tick(float dT)
{
	// get pvars and range adjust
	float amp = (float)m_amp->get_value() * (1.0f/128.0f);
	float freq = (float)m_freq->get_value() * (1.0f/128.0f) * 50.0f;

	// get the target collective
	Collective& rCol = GetCollective();

	// calculate wave function
	angle += dT * freq;
	float s = sinf(angle) * amp;
	int val = (int)(s * 128.0f);

	// apply to collective
	// this will apply to all elements and links
	rCol.set_value(val);
}
// ---------------------------------------- Mexican Wave ----------------------------
// class constructor
SA::BMexicanWave::BMexicanWave() :
m_amp(new Parameter),
m_freq(new Parameter)
{
	register_parameter("amp", m_amp);
	register_parameter("freq", m_freq);

	// init
	angle = 0;
}
// class destructor
SA::BMexicanWave::~BMexicanWave()
{}

// overloaded
void SA::BMexicanWave::tick(float dT)
{
	// get pvars and range adjust
	float amp = (float)m_amp->get_value() * (1.0f/128.0f);
	float freq = (float)m_freq->get_value() * (1.0f/128.0f) * 100.0f - 50.0f;

	// get the target collective
	Collective& rCol = GetCollective();

	float offset = TWOPI / (float)rCol.get_num_elements();

	// calculate wave function
	angle += dT * freq;

	// apply to collective.Set(n)
	for(int n = 0; n < rCol.get_num_elements(); n++) {
		float s = sinf(angle + (offset*n)) * amp;
		int val = (int)(s * 128.0f);
		rCol[n].set_value(val);
	}
}

// ---------------------------------------- Random ----------------------------
// class constructor
SA::BRandom::BRandom() :
m_amp(new Parameter),
m_freq(new Parameter)
{
	register_parameter("amp", m_amp);
	register_parameter("freq", m_freq);
}

// class destructor
SA::BRandom::~BRandom()
{}

// overloaded
void SA::BRandom::tick(float dT)
{
	// get pvars and range adjust
	float amp = (float)m_amp->get_value() * (1.0f/128.0f);
	float freq = (float)m_freq->get_value() * (1.0f/128.0f) * 100.0f - 50.0f;

	// get the target collective
	Collective& rCol = GetCollective();

	// apply to collective
	for(int r = 0; r < rCol.get_num_elements(); r++) {
		for(int c = 0; c < rCol[r].get_num_links(); c++) {
			int val = (int)((float)((rand() % 256) - 128) * amp);
			rCol[r][c].set_value(val);
		}
	}

}
